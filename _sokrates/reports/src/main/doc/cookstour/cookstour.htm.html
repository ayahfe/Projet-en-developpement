<html>
<head>
    <title>doc/cookstour/cookstour.htm</title>
    <style type="text/css" media="screen">
        #editor {
            position: absolute;
            top: 40px;
            right: 0;
            bottom: 0;
            left: 0;
        }
    </style>
</head>
<body style="font-family: 'DejaVu Sans', Arial, Helvetica, sans-serif">
<h3 style="margin-bottom: 0">doc/cookstour/cookstour.htm (<b>650</b> lines of code) (<a href="cookstour.htm">raw</a>):</h3>
<div id="editor">&lt;!doctype html public &quot;-//w3c//dtd html 4.0 transitional//en&quot;&gt;
&lt;html&gt;
&lt;head&gt;
   &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=iso-8859-1&quot;&gt;
   &lt;meta name=&quot;Generator&quot; content=&quot;Microsoft Word 97&quot;&gt;
   &lt;meta name=&quot;GENERATOR&quot; content=&quot;Mozilla/4.5 [en] (Win95; I) [Netscape]&quot;&gt;
   &lt;meta name=&quot;Author&quot; content=&quot;ERICH GAMMA&quot;&gt;
   &lt;title&gt;JUnit: A Cook�s Tour&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1&gt;
&lt;font color=&quot;#33FF33&quot;&gt;J&lt;/font&gt;&lt;font color=&quot;#CC0000&quot;&gt;U&lt;/font&gt;nit A Cook's
Tour&lt;/h1&gt;
&lt;br&gt;Note: this article is based on JUnit 3.8.x.
&lt;hr WIDTH=&quot;100%&quot;&gt;
&lt;p&gt;&lt;b&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=+1&gt;1. Introduction&lt;/font&gt;&lt;/font&gt;&lt;/b&gt;
&lt;p&gt;&lt;font size=-1&gt;In an earlier article (see Test Infected: Programmers
Love Writing Tests, Java Report, July 1998, Volume 3, Number 7), we described
how to use a simple framework to write repeatable tests. In this article,
we will take a peek under the covers and show you how the framework itself
is constructed.&lt;/font&gt;
&lt;p&gt;&lt;font size=-1&gt;We carefully studied the JUnit framework and reflected
on how we constructed it. We found lessons at many different levels. In
this article we will try communicate them all at once, a hopeless task,
but at least we will do it in the context of showing you the design and
construction of a piece of software with proven value.&lt;/font&gt;
&lt;p&gt;&lt;font size=-1&gt;We open with a discussion of the goals of the framework.
The goals will reappear in many small details during the presentation of
the framework itself. Following this, we present the design and implementation
of the framework. The design will be described in terms of patterns (surprise,
surprise), the implementation as a literate program. We conclude with a
few choice thoughts about framework development.&lt;/font&gt;
&lt;p&gt;&lt;b&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=+1&gt;2. Goals&lt;/font&gt;&lt;/font&gt;&lt;/b&gt;
&lt;p&gt;&lt;font size=-1&gt;What are the goals of JUnit?&lt;/font&gt;
&lt;p&gt;&lt;font size=-1&gt;First, we have to get back to the assumptions of development.
If a program feature lacks an automated test, we assume it doesn�t work.
This seems much safer than the prevailing assumption, that if a developer
assures us a program feature works, then it works now and forever.&lt;/font&gt;
&lt;p&gt;&lt;font size=-1&gt;From this perspective, developers aren�t done when they
write and debug the code, they must also write tests that demonstrate that
the program works. However, everybody is too busy, they have too much to
do, they don�t have enough time, to screw around with testing. I have too
much code to write already, how am I supposed write test code, too? Answer
me that, Mr. Hard-case Project Manager.&lt;/font&gt;
&lt;p&gt;&lt;font size=-1&gt;So, the number one goal is to write a framework within
which we have some glimmer of hope that developers will actually write
tests. The framework has to use familiar tools, so there is little new
to learn. It has to require no more work than absolutely necessary to write
a new test. It has to eliminate duplicated effort.&lt;/font&gt;
&lt;p&gt;&lt;font size=-1&gt;If this was all tests had to do, you would be done just
by writing expressions in a debugger. However, this isn�t sufficient for
testing. Telling me that your program works now doesn�t help me, because
it doesn�t assure me that your program will work one minute from now after
I integrate, and it doesn�t assure me that your program will still work
in five years, when you are long gone.&lt;/font&gt;
&lt;p&gt;&lt;font size=-1&gt;So, the second goal of testing is creating tests that
retain their value over time. Someone other than the original author has
to be able to execute the tests and interpret the results. It should be
possible to combine tests from various authors and run them together without
fear of interference.&lt;/font&gt;
&lt;p&gt;&lt;font size=-1&gt;Finally, it has to be possible to leverage existing tests
to create new ones. Creating a setup or fixture is expensive and a framework
has to enable reusing fixtures to run different tests. Oh, is that all?&lt;/font&gt;
&lt;p&gt;&lt;b&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=+1&gt;3. The Design of JUnit&lt;/font&gt;&lt;/font&gt;&lt;/b&gt;
&lt;p&gt;&lt;font size=-1&gt;The design of JUnit will be presented in a style first
used in (see &quot;Patterns Generate Architectures&quot;, Kent Beck and Ralph Johnson,
ECOOP 94). The idea is to explain the design of a system by starting with
nothing and applying patterns, one after another, until you have the architecture
of the system. We will present the architectural problem to be solved,
summarize the pattern that solves it, and then show how the pattern was
applied to JUnit.&lt;/font&gt;
&lt;p&gt;&lt;b&gt;&lt;i&gt;&lt;font face=&quot;Arial&quot;&gt;3.1 Getting started- TestCase&lt;/font&gt;&lt;/i&gt;&lt;/b&gt;
&lt;p&gt;&lt;font size=-1&gt;First we have to make an object to represent our basic
concept, the TestCase. Developers often have tests cases in mind, but they
realize them in many different ways-&lt;/font&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;font size=-1&gt;print statements,&lt;/font&gt;&lt;/li&gt;

&lt;li&gt;
&lt;font size=-1&gt;debugger expressions,&lt;/font&gt;&lt;/li&gt;

&lt;li&gt;
&lt;font size=-1&gt;test scripts.&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;font size=-1&gt;If we want to make manipulating tests easy, we have to make
them objects. This takes a test that was only implicit in the developer�s
mind and makes it concrete, supporting our goal of creating tests that
retain their value over time. At the same time, object developers are used
to, well, developing with objects, so the decision to make tests into objects
supports our goal of making test writing more inviting (or at least less
imposing).&lt;/font&gt;
&lt;p&gt;&lt;font size=-1&gt;The Command pattern (see Gamma, E., et al. Design Patterns:
Elements of Reusable Object-Oriented Software, Addison-Wesley, Reading,
MA, 1995) fits our needs quite nicely. Quoting from the intent, &quot;Encapsulate
a request as an object, thereby letting you� queue or log requests�&quot; Command
tells us to create an object for an operation and give it a method &quot;execute&quot;.
Here is the code for the class definition of TestCase:&lt;/font&gt;
&lt;dir&gt;
&lt;dir&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;public abstract class &lt;b&gt;TestCase&lt;/b&gt;
implements Test {&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; �&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;}&lt;/font&gt;&lt;/font&gt;&lt;/dir&gt;
&lt;/dir&gt;
&lt;font size=-1&gt;Because we expect this class to be reused through inheritance,
we declare it &quot;public abstract&quot;. For now, ignore the fact that it implements
the Test interface. For the purposes of our current design, you can think
of TestCase as a lone class.&lt;/font&gt;
&lt;p&gt;&lt;font size=-1&gt;Every TestCase is created with a name, so if a test fails,
you can identify which test failed.&lt;/font&gt;
&lt;dir&gt;
&lt;dir&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;public abstract class &lt;b&gt;TestCase&lt;/b&gt;
implements Test {&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; private final String
fName;&lt;/font&gt;&lt;/font&gt;
&lt;p&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; public &lt;b&gt;TestCase&lt;/b&gt;(String
name) {&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
fName= name;&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;/font&gt;&lt;/font&gt;
&lt;p&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; public abstract
void &lt;b&gt;run&lt;/b&gt;();&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
�&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;}&lt;/font&gt;&lt;/font&gt;&lt;/dir&gt;
&lt;/dir&gt;
&lt;font size=-1&gt;To illustrate the evolution of JUnit, we use diagrams that
show snapshots of the architecture. The notation we use is simple. It annotates
classes with shaded boxes containing the associated pattern. When the role
of the class in the pattern is obvious then only the pattern name is shown.
If the role isn�t clear then the shaded box is augmented by the name of
the participant this class corresponds to. This notation minimizes the
clutter in diagrams and was first shown in (see Gamma, E., Applying Design
Patterns in Java, in Java Gems, SIGS Reference Library, 1997) Figure 1
shows this notation applied to TestCase. Since we are dealing with a single
class and there can be no ambiguities just the pattern name is shown.&lt;/font&gt;
&lt;center&gt;
&lt;p&gt;&lt;img SRC=&quot;Image1.gif&quot; height=92 width=238&gt;
&lt;p&gt;&lt;font size=-1&gt;&lt;b&gt;Figure 1&lt;/b&gt; TestCase applies Command&lt;/font&gt;&lt;/center&gt;

&lt;p&gt;&lt;b&gt;&lt;i&gt;&lt;font face=&quot;Arial&quot;&gt;3.2 Blanks to fill in- run()&lt;/font&gt;&lt;/i&gt;&lt;/b&gt;
&lt;p&gt;&lt;font size=-1&gt;The next problem to solve is giving the developer a convenient
&quot;place&quot; to put their fixture code and their test code. The declaration
of TestCase as abstract says that the developer is expected to reuse TestCase
by subclassing. However, if all we could do was provide a superclass with
one variable and no behavior, we wouldn�t be doing much to satisfy our
first goal, making tests easier to write.&lt;/font&gt;
&lt;p&gt;&lt;font size=-1&gt;Fortunately, there is a common structure to all tests-
they set up a test fixture, run some code against the fixture, check some
results, and then clean up the fixture. This means that each test will
run with a fresh fixture and the results of one test can�t influence the
result of another. This supports the goal of maximizing the value of the
tests.&lt;/font&gt;
&lt;p&gt;&lt;font size=-1&gt;Template Method addresses our problem quite nicely. Quoting
from the intent, &quot;Define the skeleton of an algorithm in an operation,
deferring some steps to subclasses. Template Method lets subclasses redefine
certain steps of an algorithm without changing the algorithm�s structure.&quot;
This is exactly right. We want the developer to be able to separately consider
how to write the fixture (set up and tear down) code and how to write the
testing code. The execution of this sequence, however, will remain the
same for all tests, no matter how the fixture code is written or how the
testing code is written.&lt;/font&gt;
&lt;p&gt;&lt;font size=-1&gt;Here is the template method:&lt;/font&gt;
&lt;dir&gt;
&lt;dir&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;public void &lt;b&gt;run&lt;/b&gt;() {&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; setUp();&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; runTest();&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; tearDown();&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;}&lt;/font&gt;&lt;/font&gt;&lt;/dir&gt;
&lt;/dir&gt;
&lt;font size=-1&gt;The default implementations of these methods do nothing:&lt;/font&gt;
&lt;dir&gt;
&lt;dir&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;protected void &lt;b&gt;runTest&lt;/b&gt;() {&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;}&lt;/font&gt;&lt;/font&gt;
&lt;p&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;protected void &lt;b&gt;setUp&lt;/b&gt;() {&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;}&lt;/font&gt;&lt;/font&gt;
&lt;p&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;protected void &lt;b&gt;tearDown&lt;/b&gt;() {&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;}&lt;/font&gt;&lt;/font&gt;&lt;/dir&gt;
&lt;/dir&gt;
&lt;font size=-1&gt;Since setUp and tearDown are intended to be overridden but
will be called by the framework we declare them as protected. The second
snapshot of our tour is depicted in Figure 2.&lt;/font&gt;
&lt;center&gt;
&lt;p&gt;&lt;img SRC=&quot;Image2.gif&quot; height=142 width=270&gt;
&lt;p&gt;&lt;font size=-1&gt;&lt;b&gt;Figure 2&lt;/b&gt; TestCase.run() applies Template Method&lt;/font&gt;&lt;/center&gt;

&lt;p&gt;&lt;b&gt;&lt;i&gt;&lt;font face=&quot;Arial&quot;&gt;3.3 Reporting results- TestResult&lt;/font&gt;&lt;/i&gt;&lt;/b&gt;
&lt;p&gt;&lt;font size=-1&gt;If a TestCase runs in a forest, does anyone care about
the result? Sure- you run tests to make sure they run. After the test has
run, you want a record, a summary of what did and didn�t work.&lt;/font&gt;
&lt;p&gt;&lt;font size=-1&gt;If tests had equal chances of succeeding or failing, or
if we only ever ran one test, we could just set a flag in the TestCase
object and go look at the flag when the test completed. However, tests
are (intended to be) highly asymmetric- they usually work. Therefore, we
only want to record the failures and a highly condensed summary of the
successes.&lt;/font&gt;
&lt;p&gt;&lt;font size=-1&gt;The Smalltalk Best Practice Patterns (see Beck, K. Smalltalk
Best Practice Patterns, Prentice Hall, 1996) has a pattern that is applicable.
It is called &lt;i&gt;Collecting Parameter&lt;/i&gt;. It suggests that when you need
to collect results over several methods, you should add a parameter to
the method and pass an object that will collect the results for you. We
create a new object, TestResult, to collect the results of running tests.&lt;/font&gt;
&lt;dir&gt;
&lt;dir&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;public class &lt;b&gt;TestResult&lt;/b&gt; extends
Object {&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; protected int fRunTests;&lt;/font&gt;&lt;/font&gt;
&lt;p&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; public &lt;b&gt;TestResult&lt;/b&gt;()
{&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
fRunTests= 0;&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;}&lt;/font&gt;&lt;/font&gt;&lt;/dir&gt;
&lt;/dir&gt;
&lt;font size=-1&gt;This simple version of TestResult only counts the number
of tests run. To use it, we have to add a parameter to the TestCase.run()
method and notify the TestResult that the test is running:&lt;/font&gt;
&lt;dir&gt;
&lt;dir&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;public void &lt;b&gt;run&lt;/b&gt;(TestResult
result) {&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; result.startTest(this);&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; setUp();&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; runTest();&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; tearDown();&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;}&lt;/font&gt;&lt;/font&gt;&lt;/dir&gt;
&lt;/dir&gt;
&lt;font size=-1&gt;And the TestResult has to keep track of the number of tests
run:&lt;/font&gt;
&lt;dir&gt;
&lt;dir&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;public synchronized void &lt;b&gt;startTest&lt;/b&gt;(Test
test) {&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; fRunTests++;&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;}&lt;/font&gt;&lt;/font&gt;&lt;/dir&gt;
&lt;/dir&gt;
&lt;font size=-1&gt;We declare the TestResult method startTest as synchronized
so that a single TestResult can collect the results safely when the tests
are run in different threads. Finally, we want to retain the simple external
interface of TestCase, so we create a no-parameter version of run() that
creates its own TestResult:&lt;/font&gt;
&lt;dir&gt;
&lt;dir&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;public TestResult &lt;b&gt;run&lt;/b&gt;() {&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; TestResult result=
createResult();&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; run(result);&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; return result;&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;}&lt;/font&gt;&lt;/font&gt;
&lt;p&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;protected TestResult &lt;b&gt;createResult&lt;/b&gt;()
{&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; return new TestResult();&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;}&lt;/font&gt;&lt;/font&gt;&lt;/dir&gt;
&lt;/dir&gt;
&lt;font size=-1&gt;Figure 3 shows our next design snapshot.&lt;/font&gt;
&lt;center&gt;
&lt;p&gt;&lt;img SRC=&quot;Image3.gif&quot; height=149 width=325&gt;
&lt;p&gt;&lt;font size=-1&gt;Figure 3: TestResult applies Collecting Parameter&lt;/font&gt;&lt;/center&gt;

&lt;p&gt;&lt;font size=-1&gt;If tests always ran correctly, then we wouldn�t have to
write them. Tests are interesting when they fail, especially if we didn�t
expect them to fail. What�s more, tests can fail in ways that we expect,
for example by computing an incorrect result, or they can fail in more
spectacular ways, for example by writing outside the bounds of an array.
No matter how the test fails we want to execute the following tests.&lt;/font&gt;
&lt;p&gt;&lt;font size=-1&gt;JUnit distinguishes between &lt;i&gt;failures&lt;/i&gt; and &lt;i&gt;errors&lt;/i&gt;.
The possibility of a failure is anticipated and checked for with assertions.
Errors are unanticipated problems like an ArrayIndexOutOfBoundsException.
Failures are signaled with an AssertionFailedError error. To distinguish
an unanticipated error from a failure, failures are caught in an extra
catch clause (1). The second clause (2) catches all other exceptions and
ensures that our test run continues..&lt;/font&gt;
&lt;dir&gt;
&lt;dir&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;public void &lt;b&gt;run&lt;/b&gt;(TestResult
result) {&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; result.startTest(this);&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; setUp();&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; try {&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
runTest();&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; catch (AssertionFailedError
e) { //1&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
result.addFailure(this, e);&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;/font&gt;&lt;/font&gt;
&lt;p&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; catch (Throwable
e) { // 2&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
result.addError(this, e);&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; finally {&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
tearDown();&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;}&lt;/font&gt;&lt;/font&gt;&lt;/dir&gt;
&lt;/dir&gt;
&lt;font size=-1&gt;An AssertionFailedError is triggered by the assert methods
provided by TestCase. JUnit provides a set of assert methods for different
purposes. Here is the simplest one:&lt;/font&gt;
&lt;dir&gt;
&lt;dir&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;protected void &lt;b&gt;assertTrue&lt;/b&gt;(boolean
condition) {&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; if (!condition)&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
throw new AssertionFailedError();&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;}&lt;/font&gt;&lt;/font&gt;&lt;/dir&gt;
&lt;/dir&gt;
&lt;font size=-1&gt;The AssertionFailedError is not meant to be caught by the
client (a testing method inside a TestCase) but inside the Template Method
TestCase.run(). We therefore derive AssertionFailedError from Error.&lt;/font&gt;
&lt;dir&gt;
&lt;dir&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;public class &lt;b&gt;AssertionFailedError&lt;/b&gt;
extends Error {&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; public AssertionFailedError
() {}&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;}&lt;/font&gt;&lt;/font&gt;&lt;/dir&gt;
&lt;/dir&gt;
&lt;font size=-1&gt;The methods to collect the errors in TestResult are shown
below:&lt;/font&gt;
&lt;dir&gt;
&lt;dir&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;public synchronized void &lt;b&gt;addError&lt;/b&gt;(Test
test, Throwable t) {&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; fErrors.addElement(new
TestFailure(test, t));&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;}&lt;/font&gt;&lt;/font&gt;
&lt;p&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;public synchronized void &lt;b&gt;addFailure&lt;/b&gt;(Test
test, Throwable t) {&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; fFailures.addElement(new
TestFailure(test, t));&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;}&lt;/font&gt;&lt;/font&gt;&lt;/dir&gt;
&lt;/dir&gt;
&lt;font size=-1&gt;TestFailure is a little framework internal helper class to
bind together the failed test and the signaled exception for later reporting.&lt;/font&gt;
&lt;dir&gt;
&lt;dir&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;public class &lt;b&gt;TestFailure&lt;/b&gt; extends
Object {&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; protected Test
fFailedTest;&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; protected Throwable
fThrownException;&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;}&lt;/font&gt;&lt;/font&gt;&lt;/dir&gt;
&lt;/dir&gt;
&lt;font size=-1&gt;The canonical form of collecting parameter requires us to
pass the collecting parameter to each method. If we followed this advice,
each of the testing methods would require a parameter for the TestResult.
This results in a &quot;pollution&quot; of these method signatures. As a benevolent
side effect of using exceptions to signal failures we can avoid this signature
pollution. A test case method, or a helper method called from it, can throw
an exception without having to know about the TestResult. As a refresher
here is a sample test method from our MoneyTest suite. It illustrates how
a testing method doesn�t have to know anything about a TestResult:&lt;/font&gt;
&lt;dir&gt;
&lt;dir&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;public void &lt;b&gt;testMoneyEquals&lt;/b&gt;()
{&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; assertTrue(!f12CHF.equals(null));&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; assertEquals(f12CHF,
f12CHF);&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; assertEquals(f12CHF,
new Money(12, &quot;CHF&quot;));&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; assertTrue(!f12CHF.equals(f14CHF));&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;}&lt;/font&gt;&lt;/font&gt;&lt;/dir&gt;
&lt;/dir&gt;
&lt;font size=-1&gt;JUnit comes with different implementations of TestResult.
The default implementation counts the number of failures and errors and
collects the results. TextTestResult collects the results and presents
them in a textual form. Finally, UITestResult is used by the graphical
version of the JUnit Test Runner to update the graphical test status.&lt;/font&gt;
&lt;p&gt;&lt;font size=-1&gt;TestResult is an extension point of the framework. Clients
can define their own custom TestResult classes, for example, an HTMLTestResult
reports the results as an HTML document.&lt;/font&gt;
&lt;p&gt;&lt;b&gt;&lt;i&gt;&lt;font face=&quot;Arial&quot;&gt;3.4 No stupid subclasses - TestCase again&lt;/font&gt;&lt;/i&gt;&lt;/b&gt;
&lt;p&gt;&lt;font size=-1&gt;We have applied Command to represent a test. Command relies
on a single method like execute() (called run() in TestCase) to invoke
it. This simple interface allows us to invoke different implementations
of a command through the same interface.&lt;/font&gt;
&lt;p&gt;&lt;font size=-1&gt;We need an interface to generically run our tests. However,
all test cases are implemented as different methods in the same class.
This avoids the unnecessary proliferation of classes. A given test case
class may implement many different methods, each defining a single test
case. Each test case has a descriptive name like testMoneyEquals or testMoneyAdd.
The test cases don�t conform to a simple command interface. Different instances
of the same Command class need to be invoked with different methods. Therefore
our next problem is make all the test cases look the same from the point
of view of the invoker of the test.&lt;/font&gt;
&lt;p&gt;&lt;font size=-1&gt;Reviewing the problems addressed by available design patterns,
the Adapter pattern springs to mind. Adapter has the following intent &quot;Convert
the interface of a class into another interface clients expect&quot;. This sounds
like a good match. Adapter tells us different ways to do this. One of them
is a class adapter, which uses subclassing to adapt the interface. For
example, to adapt testMoneyEquals to runTest we implement a subclass of
MoneyTest and override runTest to invoke testMoneyEquals.&lt;/font&gt;
&lt;dir&gt;
&lt;dir&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;public class &lt;b&gt;TestMoneyEquals&lt;/b&gt;
extends MoneyTest {&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; public TestMoneyEquals()
{ super(&quot;testMoneyEquals&quot;); }&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; protected void
runTest () { testMoneyEquals(); }&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;}&lt;/font&gt;&lt;/font&gt;&lt;/dir&gt;
&lt;/dir&gt;
&lt;font size=-1&gt;The use of subclassing requires us to implement a subclass
for each test case. This puts an additional burden on the tester. This
is against the JUnit goal that the framework should make it as simple as
possible to add a test case. In addition, creating a subclass for each
testing method results in class bloat. Many classes with only a single
method are not worth their costs and it will be difficult to come up with
meaningful names.&lt;/font&gt;
&lt;p&gt;&lt;font size=-1&gt;Java provides anonymous inner classes which provide an
interesting Java-specific solution to the class naming problem. With anonymous
inner classes we can create an Adapter without having to invent a class
name:&lt;/font&gt;
&lt;dir&gt;
&lt;dir&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;TestCase test= new MoneyTest(&quot;testMoneyEquals
&quot;) {&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; protected void
runTest() { testMoneyEquals(); }&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;};&lt;/font&gt;&lt;/font&gt;&lt;/dir&gt;
&lt;/dir&gt;
&lt;font size=-1&gt;This is much more convenient than full subclassing. It preserves
compile-time type checking at the cost of some burden on the developer.
Smalltalk Best Practice Patterns describes another solution for the problem
of different instances behaving differently under the common heading of&lt;i&gt;
pluggable behavior&lt;/i&gt;. The idea is to use a single class which can be
parameterized to perform different logic without requiring subclassing.&lt;/font&gt;
&lt;p&gt;&lt;font size=-1&gt;The simplest form of pluggable behavior is the &lt;i&gt;Pluggable
Selector&lt;/i&gt;. Pluggable Selector stores a Smalltalk method selector in
an instance variable. This idea is not limited to Smalltalk. It is also
applicable to Java. In Java there is no notion of a method selector. However,
the Java reflection API allows us to invoke a method from a string representing
the method�s name. We can use this feature to implement a pluggable selector
in Java. As an aside, we usually don�t use reflection in ordinary application
code. In our case we are dealing with an infrastructure framework and it
is therefore OK to wear the reflection hat.&lt;/font&gt;
&lt;p&gt;&lt;font size=-1&gt;JUnit offers the client the choice of using pluggable
selector or implementing an anonymous adapter class as shown above. To
do so, we provide the pluggable selector as the default implementation
of the runTest method. In this case the name of the test case has to correspond
to the name of a test method. We use reflection to invoke the method as
shown below. First we look up the Method object. Once we have the method
object we can invoke it and pass its arguments. Since our test methods
take no arguments we can pass an empty argument array:&lt;/font&gt;
&lt;dir&gt;
&lt;dir&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;protected void &lt;b&gt;runTest&lt;/b&gt;() throws
Throwable {&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; Method runMethod=
null;&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; try {&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
runMethod= getClass().getMethod(fName, new Class[0]);&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; } catch (NoSuchMethodException
e) {&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
assertTrue(&quot;Method \&quot;&quot;+fName+&quot;\&quot; not found&quot;, false);&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; try {&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
runMethod.invoke(this, new Class[0]);&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; // catch InvocationTargetException
and IllegalAccessException&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;}&lt;/font&gt;&lt;/font&gt;&lt;/dir&gt;
&lt;/dir&gt;
&lt;font size=-1&gt;The JDK 1.1 reflection API only allows us to find public
methods. For this reason you have to declare the test methods as public,
otherwise you will get a NoSuchMethodException.&lt;/font&gt;
&lt;p&gt;&lt;font size=-1&gt;Here is the next design snapshot, with Adapter and Pluggable
Selector added.&lt;/font&gt;
&lt;center&gt;
&lt;p&gt;&lt;img SRC=&quot;Image4.gif&quot; height=271 width=278&gt;
&lt;p&gt;&lt;font size=-1&gt;Figure 4: TestCase applies either Adapter with an anonymous
inner class or Pluggable Selector&lt;/font&gt;&lt;/center&gt;

&lt;p&gt;&lt;b&gt;&lt;i&gt;&lt;font face=&quot;Arial&quot;&gt;3.5 Don�t care about one or many - TestSuite&lt;/font&gt;&lt;/i&gt;&lt;/b&gt;
&lt;p&gt;&lt;font size=-1&gt;To get confidence in the state of a system we need to
run many tests. Up to this point JUnit can run a single test case and report
the result in a TestResult. Our next challenge is to extend it so that
it can run many different tests. This problem can be solved easily when
the invoker of the tests doesn�t have to care about whether it runs one
or many test cases. A popular pattern to pull out in such a situation is
Composite. To quote its intent &quot;Compose objects into tree structures to
represent part-whole hierarchies. Composite lets clients treat individual
objects and compositions of objects uniformly.&quot; The point about part-whole
hierarchies is of interest here. We want to support suites of suites of
suites of tests.&lt;/font&gt;
&lt;p&gt;&lt;font size=-1&gt;Composite introduces the following participants:&lt;/font&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;font size=-1&gt;Component: declares the interface we want to use to interact
with our tests.&lt;/font&gt;&lt;/li&gt;

&lt;li&gt;
&lt;font size=-1&gt;Composite: implements this interface and maintains a collection
of tests.&lt;/font&gt;&lt;/li&gt;

&lt;li&gt;
&lt;font size=-1&gt;Leaf: represents a test case in a composition that conforms
to the Component interface.&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;font size=-1&gt;The pattern tells us to introduce an abstract class which
defines the common interface for single and composite objects. The primary
purpose of the class is to define an interface. When applying Composite
in Java we prefer to define an interface and not an abstract class. Using
an interface avoids committing JUnit to a specific base class for tests.
All that is required is that the tests conform to this interface. We therefore
tweak the pattern description and introduce a Test interface:&lt;/font&gt;
&lt;dir&gt;
&lt;dir&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;public interface &lt;b&gt;Test&lt;/b&gt; {&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; public abstract
void run(TestResult result);&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;}&lt;/font&gt;&lt;/font&gt;&lt;/dir&gt;
&lt;/dir&gt;
&lt;font size=-1&gt;TestCase corresponds to a Leaf in Composite and implements
this interface as we have seen above.&lt;/font&gt;
&lt;p&gt;&lt;font size=-1&gt;Next, we introduce the Composite participant. We name
the class TestSuite. A TestSuite keeps its child tests in a Vector:&lt;/font&gt;
&lt;dir&gt;
&lt;dir&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;public class &lt;b&gt;TestSuite&lt;/b&gt; implements
&lt;b&gt;Test&lt;/b&gt;
{&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; private Vector
fTests= new Vector();&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;}&lt;/font&gt;&lt;/font&gt;&lt;/dir&gt;
&lt;/dir&gt;
&lt;font size=-1&gt;The run() method delegates to its children:&lt;/font&gt;
&lt;dir&gt;
&lt;dir&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;public void &lt;b&gt;run&lt;/b&gt;(TestResult
result) {&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; for (Enumeration
e= fTests.elements(); e.hasMoreElements(); ) {&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
Test test= (Test)e.nextElement();&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
test.run(result);&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;}&lt;/font&gt;&lt;/font&gt;&lt;/dir&gt;
&lt;/dir&gt;

&lt;center&gt;&lt;img SRC=&quot;Image5.gif&quot; height=241 width=562&gt;
&lt;p&gt;&lt;font size=-1&gt;Figure 5: TestSuite applies Composite&lt;/font&gt;&lt;/center&gt;

&lt;p&gt;&lt;font size=-1&gt;Finally, clients have to be able to add tests to a suite,
they can do so with the method addTest:&lt;/font&gt;
&lt;dir&gt;
&lt;dir&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;public void &lt;b&gt;addTest&lt;/b&gt;(Test test)
{&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; fTests.addElement(test);&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;}&lt;/font&gt;&lt;/font&gt;&lt;/dir&gt;
&lt;/dir&gt;
&lt;font size=-1&gt;Notice how all of the above code only depends on the Test
interface. Since both TestCase and TestSuite conform to the Test interface
we can recursively compose suites of test suites. All developers can create
their own TestSuites. We can run them all by creating a TestSuite composed
of those suites.&lt;/font&gt;
&lt;p&gt;&lt;font size=-1&gt;Here is an example of creating a TestSuite:&lt;/font&gt;
&lt;dir&gt;
&lt;dir&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;public static Test &lt;b&gt;suite&lt;/b&gt;()
{&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; TestSuite suite=
new TestSuite();&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; suite.addTest(new
MoneyTest(&quot;testMoneyEquals&quot;));&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; suite.addTest(new
MoneyTest(&quot;testSimpleAdd&quot;));&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;}&lt;/font&gt;&lt;/font&gt;&lt;/dir&gt;
&lt;/dir&gt;
&lt;font size=-1&gt;This works fine, but it requires us to add all the tests
to a suite manually. Early adopters of JUnit told us this was stupid. Whenever
you write a new test case you have to remember to add it to a static suite()
method, otherwise it will not be run. We added a convenience constructor
to TestSuite which takes the test case class as an argument. Its purpose
is to extract the test methods and create a suite containing them. The
test methods must follow the simple convention that they start with the
prefix &quot;test&quot; and take no arguments. The convenience constructor uses this
convention, constructing the test objects by using reflection to find the
testing methods. Using this constructor the above code is simplified to:&lt;/font&gt;
&lt;dir&gt;
&lt;dir&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;public static Test &lt;b&gt;suite&lt;/b&gt;()
{&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; return new TestSuite(MoneyTest.class);&lt;/font&gt;&lt;/font&gt;
&lt;br&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-2&gt;}&lt;/font&gt;&lt;/font&gt;&lt;/dir&gt;
&lt;/dir&gt;
&lt;font size=-1&gt;The original way is still useful when you want to run a subset
of the test cases only.&lt;/font&gt;
&lt;p&gt;&lt;b&gt;&lt;i&gt;&lt;font face=&quot;Arial&quot;&gt;3.6 Summary&lt;/font&gt;&lt;/i&gt;&lt;/b&gt;
&lt;p&gt;&lt;font size=-1&gt;We are at the end of our cook�s tour through JUnit. The
following figure shows the design of JUnit at a glance explained with patterns.&lt;/font&gt;
&lt;center&gt;
&lt;p&gt;&lt;img SRC=&quot;Image6.gif&quot; height=394 width=605&gt;
&lt;p&gt;&lt;font size=-1&gt;Figure 6: JUnit Patterns Summary&lt;/font&gt;&lt;/center&gt;

&lt;p&gt;&lt;font size=-1&gt;Notice how TestCase, the central abstraction in the framework,
is involved in four patterns. Pictures of mature object designs show this
same &quot;pattern density&quot;. The star of the design has a rich set of relationships
with the supporting players.&lt;/font&gt;
&lt;p&gt;&lt;font size=-1&gt;Here is another way of looking at all of the patterns
in JUnit. In this storyboard you see an abstract representation of the
effect of each of the patterns in turn. So, the Command pattern creates
the TestCase class, the Template Method pattern creates the run method,
and so on. (The notation of the storyboard is the notation of figure 6
with all the text deleted).&lt;/font&gt;
&lt;center&gt;
&lt;p&gt;&lt;img SRC=&quot;Image7.gif&quot; height=231 width=792&gt;
&lt;p&gt;&lt;font size=-1&gt;Figure 7: JUnit Pattern Storyboard&lt;/font&gt;&lt;/center&gt;

&lt;p&gt;&lt;font size=-1&gt;One point to notice about the storyboard is how the complexity
of the picture jumps when we apply Composite. This is pictorial corroboration
for our intuition that Composite is a powerful pattern, but that it &quot;complicates
the picture.&quot; It should therefore be used with caution.&lt;/font&gt;
&lt;p&gt;&lt;b&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=+1&gt;4. Conclusion&lt;/font&gt;&lt;/font&gt;&lt;/b&gt;
&lt;p&gt;&lt;font size=-1&gt;To conclude, let�s make some general observations:&lt;/font&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;i&gt;&lt;font size=-1&gt;Patterns&lt;/font&gt;&lt;/i&gt;&lt;/li&gt;

&lt;br&gt;&lt;font size=-1&gt;We found discussing the design in terms of patterns to
be invaluable, both as we were developing the framework and as we try to
explain it to others. You are now in a perfect position to judge whether
describing a framework with patterns is effective. If you liked the discussion
above, try the same style of presentation for your own system.&lt;/font&gt;
&lt;li&gt;
&lt;i&gt;&lt;font size=-1&gt;Pattern density&lt;/font&gt;&lt;/i&gt;&lt;/li&gt;

&lt;br&gt;&lt;font size=-1&gt;There is a high pattern &quot;density&quot; around TestCase, which
is the key abstraction of JUnit. Designs with high pattern density are
easier to use but harder to change. We have found that such a high pattern
density around key abstractions is common for mature frameworks. The opposite
should be true of immature frameworks - they should have low pattern density.
Once you discover what problem you are really solving, then you can begin
to &quot;compress&quot; the solution, leading to a denser and denser field of patterns
where they provide leverage.&lt;/font&gt;
&lt;li&gt;
&lt;i&gt;&lt;font size=-1&gt;Eat your own dog food&lt;/font&gt;&lt;/i&gt;&lt;/li&gt;

&lt;br&gt;&lt;font size=-1&gt;As soon as we had the base unit testing functionality
implemented, we applied it ourselves. A TestTest verifies that the framework
reports the correct results for errors, successes, and failures. We found
this invaluable as we continued to evolve the design of the framework.
We found that the most challenging application of JUnit was testing its
own behavior.&lt;/font&gt;
&lt;li&gt;
&lt;i&gt;&lt;font size=-1&gt;Intersection, not union&lt;/font&gt;&lt;/i&gt;&lt;/li&gt;

&lt;br&gt;&lt;font size=-1&gt;There is a temptation in framework development to include
every feature you can. After all, you want to make the framework as valuable
as possible. However, there is a counteracting force- developers have to
decide to use your framework. The fewer features the framework has, the
easier it is to learn, the more likely a developer will use it. JUnit is
written in this style. It implements only those features absolutely essential
to running tests- running suites of tests, isolating the execution of tests
from each other, and running tests automatically. Sure, we couldn�t resist
adding some features but we were careful to put them into their own extensions
package (test.extensions). A notable member of this package is a TestDecorator
allowing execution of additional code before and after a test.&lt;/font&gt;
&lt;li&gt;
&lt;i&gt;&lt;font size=-1&gt;Framework writers read their code&lt;/font&gt;&lt;/i&gt;&lt;/li&gt;

&lt;br&gt;&lt;font size=-1&gt;We spent far more time reading the JUnit code than we
spent writing it, and nearly as much time removing duplicate functionality
as we spent adding new functionality. We experimented aggressively with
the design, adding new classes and moving responsibility around in as many
different ways as we could imagine. We were rewarded (and are still being
rewarded) for our monomania by a continuous flow of insights into JUnit,
testing, object design, framework development, and opportunities for further
articles.&lt;/font&gt;&lt;/ul&gt;
&lt;font size=-1&gt;The latest version of JUnit can be downloaded from http://www.junit.org.&lt;/font&gt;
&lt;p&gt;&lt;b&gt;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=+1&gt;5. Acknowledgements&lt;/font&gt;&lt;/font&gt;&lt;/b&gt;
&lt;p&gt;&lt;font size=-1&gt;Thanks to John Vlissides, Ralph Johnson, and Nick Edgar
for careful reading and gentle correction.&lt;/font&gt;
&lt;/body&gt;
&lt;/html&gt;
</div>
<script src="https://www.zeljkoobrenovic.com/tools/common/lib/ace/ace.js" type="text/javascript" charset="utf-8"></script>
<script>
    var editor = ace.edit("editor");
    editor.session.setMode("ace/mode/html");
    editor.setTheme("ace/theme/xcode");
    editor.setReadOnly(true);
    editor.setOption("wrap", true);
    editor.setPrintMarginColumn(120);
</script>
</body>
