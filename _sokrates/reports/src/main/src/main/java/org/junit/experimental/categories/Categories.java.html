<html>
<head>
    <title>src/main/java/org/junit/experimental/categories/Categories.java</title>
    <style type="text/css" media="screen">
        #editor {
            position: absolute;
            top: 40px;
            right: 0;
            bottom: 0;
            left: 0;
        }
    </style>
</head>
<body style="font-family: 'DejaVu Sans', Arial, Helvetica, sans-serif">
<h3 style="margin-bottom: 0">src/main/java/org/junit/experimental/categories/Categories.java (<b>220</b> lines of code) (<a href="Categories.java">raw</a>):</h3>
<div id="editor">package org.junit.experimental.categories;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;

import org.junit.runner.Description;
import org.junit.runner.manipulation.Filter;
import org.junit.runner.manipulation.NoTestsRemainException;
import org.junit.runners.Suite;
import org.junit.runners.model.InitializationError;
import org.junit.runners.model.RunnerBuilder;

/**
 * From a given set of test classes, runs only the classes and methods that are
 * annotated with either the category given with the @IncludeCategory
 * annotation, or a subtype of that category.
 * &lt;p&gt;
 * Note that, for now, annotating suites with {@code @Category} has no effect.
 * Categories must be annotated on the direct method or class.
 * &lt;p&gt;
 * Example:
 * &lt;pre&gt;
 * public interface FastTests {
 * }
 *
 * public interface SlowTests {
 * }
 *
 * public interface SmokeTests
 * }
 *
 * public static class A {
 *     &amp;#064;Test
 *     public void a() {
 *         fail();
 *     }
 *
 *     &amp;#064;Category(SlowTests.class)
 *     &amp;#064;Test
 *     public void b() {
 *     }
 *
 *     &amp;#064;Category({FastTests.class, SmokeTests.class})
 *     &amp;#064;Test
 *     public void c() {
 *     }
 * }
 *
 * &amp;#064;Category({SlowTests.class, FastTests.class})
 * public static class B {
 *     &amp;#064;Test
 *     public void d() {
 *     }
 * }
 *
 * &amp;#064;RunWith(Categories.class)
 * &amp;#064;IncludeCategory(SlowTests.class)
 * &amp;#064;SuiteClasses({A.class, B.class})
 * // Note that Categories is a kind of Suite
 * public static class SlowTestSuite {
 *     // Will run A.b and B.d, but not A.a and A.c
 * }
 * &lt;/pre&gt;
 * &lt;p&gt;
 * Example to run multiple categories:
 * &lt;pre&gt;
 * &amp;#064;RunWith(Categories.class)
 * &amp;#064;IncludeCategory({FastTests.class, SmokeTests.class})
 * &amp;#064;SuiteClasses({A.class, B.class})
 * public static class FastOrSmokeTestSuite {
 *     // Will run A.c and B.d, but not A.b because it is not any of FastTests or SmokeTests
 * }
 * &lt;/pre&gt;
 *
 * @version 4.12
 * @see &lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Categories&quot;&gt;Categories at JUnit wiki&lt;/a&gt;
 */
public class Categories extends Suite {

    @Retention(RetentionPolicy.RUNTIME)
    public @interface IncludeCategory {
        /**
         * Determines the tests to run that are annotated with categories specified in
         * the value of this annotation or their subtypes unless excluded with {@link ExcludeCategory}.
         */
        Class&lt;?&gt;[] value() default {};

        /**
         * If &lt;tt&gt;true&lt;/tt&gt;, runs tests annotated with &lt;em&gt;any&lt;/em&gt; of the categories in
         * {@link IncludeCategory#value()}. Otherwise, runs tests only if annotated with &lt;em&gt;all&lt;/em&gt; of the categories.
         */
        boolean matchAny() default true;
    }

    @Retention(RetentionPolicy.RUNTIME)
    public @interface ExcludeCategory {
        /**
         * Determines the tests which do not run if they are annotated with categories specified in the
         * value of this annotation or their subtypes regardless of being included in {@link IncludeCategory#value()}.
         */
        Class&lt;?&gt;[] value() default {};

        /**
         * If &lt;tt&gt;true&lt;/tt&gt;, the tests annotated with &lt;em&gt;any&lt;/em&gt; of the categories in {@link ExcludeCategory#value()}
         * do not run. Otherwise, the tests do not run if and only if annotated with &lt;em&gt;all&lt;/em&gt; categories.
         */
        boolean matchAny() default true;
    }

    public static class CategoryFilter extends Filter {
        private final Set&lt;Class&lt;?&gt;&gt; included;
        private final Set&lt;Class&lt;?&gt;&gt; excluded;
        private final boolean includedAny;
        private final boolean excludedAny;

        public static CategoryFilter include(boolean matchAny, Class&lt;?&gt;... categories) {
            return new CategoryFilter(matchAny, categories, true, null);
        }

        public static CategoryFilter include(Class&lt;?&gt; category) {
            return include(true, category);
        }

        public static CategoryFilter include(Class&lt;?&gt;... categories) {
            return include(true, categories);
        }

        public static CategoryFilter exclude(boolean matchAny, Class&lt;?&gt;... categories) {
            return new CategoryFilter(true, null, matchAny, categories);
        }

        public static CategoryFilter exclude(Class&lt;?&gt; category) {
            return exclude(true, category);
        }

        public static CategoryFilter exclude(Class&lt;?&gt;... categories) {
            return exclude(true, categories);
        }

        public static CategoryFilter categoryFilter(boolean matchAnyInclusions, Set&lt;Class&lt;?&gt;&gt; inclusions,
                                                    boolean matchAnyExclusions, Set&lt;Class&lt;?&gt;&gt; exclusions) {
            return new CategoryFilter(matchAnyInclusions, inclusions, matchAnyExclusions, exclusions);
        }

        @Deprecated
        public CategoryFilter(Class&lt;?&gt; includedCategory, Class&lt;?&gt; excludedCategory) {
            includedAny = true;
            excludedAny = true;
            included = nullableClassToSet(includedCategory);
            excluded = nullableClassToSet(excludedCategory);
        }

        protected CategoryFilter(boolean matchAnyIncludes, Set&lt;Class&lt;?&gt;&gt; includes,
                                 boolean matchAnyExcludes, Set&lt;Class&lt;?&gt;&gt; excludes) {
            includedAny = matchAnyIncludes;
            excludedAny = matchAnyExcludes;
            included = copyAndRefine(includes);
            excluded = copyAndRefine(excludes);
        }

        private CategoryFilter(boolean matchAnyIncludes, Class&lt;?&gt;[] inclusions,
                               boolean matchAnyExcludes, Class&lt;?&gt;[] exclusions) {
            includedAny = matchAnyIncludes; 
            excludedAny = matchAnyExcludes;
            included = createSet(inclusions);
            excluded = createSet(exclusions);
        }

        /**
         * @see #toString()
         */
        @Override
        public String describe() {
            return toString();
        }

        /**
         * Returns string in the form &lt;tt&gt;&amp;quot;[included categories] - [excluded categories]&amp;quot;&lt;/tt&gt;, where both
         * sets have comma separated names of categories.
         *
         * @return string representation for the relative complement of excluded categories set
         * in the set of included categories. Examples:
         * &lt;ul&gt;
         *  &lt;li&gt; &lt;tt&gt;&amp;quot;categories [all]&amp;quot;&lt;/tt&gt; for all included categories and no excluded ones;
         *  &lt;li&gt; &lt;tt&gt;&amp;quot;categories [all] - [A, B]&amp;quot;&lt;/tt&gt; for all included categories and given excluded ones;
         *  &lt;li&gt; &lt;tt&gt;&amp;quot;categories [A, B] - [C, D]&amp;quot;&lt;/tt&gt; for given included categories and given excluded ones.
         * &lt;/ul&gt;
         * @see Class#toString() name of category
         */
        @Override public String toString() {
            StringBuilder description= new StringBuilder(&quot;categories &quot;)
                .append(included.isEmpty() ? &quot;[all]&quot; : included);
            if (!excluded.isEmpty()) {
                description.append(&quot; - &quot;).append(excluded);
            }
            return description.toString();
        }

        @Override
        public boolean shouldRun(Description description) {
            if (hasCorrectCategoryAnnotation(description)) {
                return true;
            }

            for (Description each : description.getChildren()) {
                if (shouldRun(each)) {
                    return true;
                }
            }

            return false;
        }

        private boolean hasCorrectCategoryAnnotation(Description description) {
            final Set&lt;Class&lt;?&gt;&gt; childCategories= categories(description);

            // If a child has no categories, immediately return.
            if (childCategories.isEmpty()) {
                return included.isEmpty();
            }

            if (!excluded.isEmpty()) {
                if (excludedAny) {
                    if (matchesAnyParentCategories(childCategories, excluded)) {
                        return false;
                    }
                } else {
                    if (matchesAllParentCategories(childCategories, excluded)) {
                        return false;
                    }
                }
            }

            if (included.isEmpty()) {
                // Couldn't be excluded, and with no suite's included categories treated as should run.
                return true;
            } else {
                if (includedAny) {
                    return matchesAnyParentCategories(childCategories, included);
                } else {
                    return matchesAllParentCategories(childCategories, included);
                }
            }
        }

        /**
         * @return &lt;tt&gt;true&lt;/tt&gt; if at least one (any) parent category match a child, otherwise &lt;tt&gt;false&lt;/tt&gt;.
         * If empty &lt;tt&gt;parentCategories&lt;/tt&gt;, returns &lt;tt&gt;false&lt;/tt&gt;.
         */
        private boolean matchesAnyParentCategories(Set&lt;Class&lt;?&gt;&gt; childCategories, Set&lt;Class&lt;?&gt;&gt; parentCategories) {
            for (Class&lt;?&gt; parentCategory : parentCategories) {
                if (hasAssignableTo(childCategories, parentCategory)) {
                    return true;
                }
            }
            return false;
        }

        /**
         * @return &lt;tt&gt;false&lt;/tt&gt; if at least one parent category does not match children, otherwise &lt;tt&gt;true&lt;/tt&gt;.
         * If empty &lt;tt&gt;parentCategories&lt;/tt&gt;, returns &lt;tt&gt;true&lt;/tt&gt;.
         */
        private boolean matchesAllParentCategories(Set&lt;Class&lt;?&gt;&gt; childCategories, Set&lt;Class&lt;?&gt;&gt; parentCategories) {
            for (Class&lt;?&gt; parentCategory : parentCategories) {
                if (!hasAssignableTo(childCategories, parentCategory)) {
                    return false;
                }
            }
            return true;
        }

        private static Set&lt;Class&lt;?&gt;&gt; categories(Description description) {
            Set&lt;Class&lt;?&gt;&gt; categories= new HashSet&lt;Class&lt;?&gt;&gt;();
            Collections.addAll(categories, directCategories(description));
            Collections.addAll(categories, directCategories(parentDescription(description)));
            return categories;
        }

        private static Description parentDescription(Description description) {
            Class&lt;?&gt; testClass= description.getTestClass();
            return testClass == null ? null : Description.createSuiteDescription(testClass);
        }

        private static Class&lt;?&gt;[] directCategories(Description description) {
            if (description == null) {
                return new Class&lt;?&gt;[0];
            }

            Category annotation= description.getAnnotation(Category.class);
            return annotation == null ? new Class&lt;?&gt;[0] : annotation.value();
        }

        private static Set&lt;Class&lt;?&gt;&gt; copyAndRefine(Set&lt;Class&lt;?&gt;&gt; classes) {
            Set&lt;Class&lt;?&gt;&gt; c= new LinkedHashSet&lt;Class&lt;?&gt;&gt;();
            if (classes != null) {
                c.addAll(classes);
            }
            c.remove(null);
            return c;
        }
    }

    public Categories(Class&lt;?&gt; klass, RunnerBuilder builder) throws InitializationError {
        super(klass, builder);
        try {
            Set&lt;Class&lt;?&gt;&gt; included= getIncludedCategory(klass);
            Set&lt;Class&lt;?&gt;&gt; excluded= getExcludedCategory(klass);
            boolean isAnyIncluded= isAnyIncluded(klass);
            boolean isAnyExcluded= isAnyExcluded(klass);

            filter(CategoryFilter.categoryFilter(isAnyIncluded, included, isAnyExcluded, excluded));
        } catch (NoTestsRemainException e) {
            throw new InitializationError(e);
        }
    }

    private static Set&lt;Class&lt;?&gt;&gt; getIncludedCategory(Class&lt;?&gt; klass) {
        IncludeCategory annotation= klass.getAnnotation(IncludeCategory.class);
        return createSet(annotation == null ? null : annotation.value());
    }

    private static boolean isAnyIncluded(Class&lt;?&gt; klass) {
        IncludeCategory annotation= klass.getAnnotation(IncludeCategory.class);
        return annotation == null || annotation.matchAny();
    }

    private static Set&lt;Class&lt;?&gt;&gt; getExcludedCategory(Class&lt;?&gt; klass) {
        ExcludeCategory annotation= klass.getAnnotation(ExcludeCategory.class);
        return createSet(annotation == null ? null : annotation.value());
    }

    private static boolean isAnyExcluded(Class&lt;?&gt; klass) {
        ExcludeCategory annotation= klass.getAnnotation(ExcludeCategory.class);
        return annotation == null || annotation.matchAny();
    }

    private static boolean hasAssignableTo(Set&lt;Class&lt;?&gt;&gt; assigns, Class&lt;?&gt; to) {
        for (final Class&lt;?&gt; from : assigns) {
            if (to.isAssignableFrom(from)) {
                return true;
            }
        }
        return false;
    }

    private static Set&lt;Class&lt;?&gt;&gt; createSet(Class&lt;?&gt;[] classes) {
        // Not throwing a NPE if t is null is a bad idea, but it's the behavior from JUnit 4.12
        // for include(boolean, Class&lt;?&gt;...) and exclude(boolean, Class&lt;?&gt;...)
        if (classes == null || classes.length == 0) {
            return Collections.emptySet();
        }
        for (Class&lt;?&gt; category : classes) {
            if (category == null) {
                throw new NullPointerException(&quot;has null category&quot;);
            }
        }

        return classes.length == 1
            ? Collections.&lt;Class&lt;?&gt;&gt;singleton(classes[0])
            : new LinkedHashSet&lt;Class&lt;?&gt;&gt;(Arrays.asList(classes));
    }

    private static Set&lt;Class&lt;?&gt;&gt; nullableClassToSet(Class&lt;?&gt; nullableClass) {
        // Not throwing a NPE if t is null is a bad idea, but it's the behavior from JUnit 4.11
        // for CategoryFilter(Class&lt;?&gt; includedCategory, Class&lt;?&gt; excludedCategory)
        return nullableClass == null
                ? Collections.&lt;Class&lt;?&gt;&gt;emptySet()
                : Collections.&lt;Class&lt;?&gt;&gt;singleton(nullableClass);
    }
}
</div>
<script src="https://www.zeljkoobrenovic.com/tools/common/lib/ace/ace.js" type="text/javascript" charset="utf-8"></script>
<script>
    var editor = ace.edit("editor");
    editor.session.setMode("ace/mode/java");
    editor.setTheme("ace/theme/xcode");
    editor.setReadOnly(true);
    editor.setOption("wrap", true);
    editor.setPrintMarginColumn(120);
</script>
</body>
