<html>
<head>
    <title>doc/ReleaseNotes4.4.html</title>
    <style type="text/css" media="screen">
        #editor {
            position: absolute;
            top: 40px;
            right: 0;
            bottom: 0;
            left: 0;
        }
    </style>
</head>
<body style="font-family: 'DejaVu Sans', Arial, Helvetica, sans-serif">
<h3 style="margin-bottom: 0">doc/ReleaseNotes4.4.html (<b>212</b> lines of code) (<a href="ReleaseNotes4.4.html">raw</a>):</h3>
<div id="editor">&lt;h2&gt;Summary of Changes in version 4.5&lt;/h2&gt;

&lt;h3&gt;Categories&lt;/h3&gt;

&lt;p&gt;Each test method and test class can be annotated as belonging to a &lt;em&gt;category&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static class SomeUITests {
    @Category(UserAvailable.class)
    @Test
    public void askUserToPressAKey() { }

    @Test
    public void simulatePressingKey() { }
}

@Category(InternetConnected.class)
public static class InternetTests {
    @Test
    public void pingServer() { }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To run all of the tests in a particular category, you must currently explicitly create a custom request:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;new JUnitCore().run(Request.aClass(SomeUITests.class).inCategories(UserAvailable.class));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This feature will very likely be improved before the final release of JUnit 4.5&lt;/p&gt;

&lt;h3&gt;Miscellaneous&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;@Before&lt;/code&gt; and &lt;code&gt;@After&lt;/code&gt; methods are run before and after each set of attempted parameters
on a Theory&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Refactoring removed duplication that used to exist in classes MethodRoadie and ClassRoadie&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Exposed API &lt;code&gt;ParameterSignature.getType()&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Summary of Changes in version 4.4&lt;/h2&gt;

&lt;p&gt;JUnit is designed to efficiently capture developers' intentions about
their code, and quickly check their code matches those intentions.
Over the last year, we've been talking about what things developers
would like to say about their code that have been difficult in the
past, and how we can make them easier.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://sourceforge.net/project/showfiles.php?group_id=15278&quot;&gt;Download&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;assertThat&lt;/h3&gt;

&lt;p&gt;Two years ago, Joe Walnes built a &lt;a href=&quot;http://joewalnes.com/2005/05/13/flexible-junit-assertions-with-assertthat/&quot;&gt;new assertion mechanism&lt;/a&gt; on top of what was 
then &lt;a href=&quot;http://www.jmock.org/download.html&quot;&gt;JMock 1&lt;/a&gt;.  The method name was &lt;code&gt;assertThat&lt;/code&gt;, and the syntax looked like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;assertThat(x, is(3));
assertThat(x, is(not(4)));
assertThat(responseString, either(containsString(&quot;color&quot;)).or(containsString(&quot;colour&quot;)));
assertThat(myList, hasItem(&quot;3&quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;More generally:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;assertThat([value], [matcher statement]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Advantages of this assertion syntax include:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;More readable and typeable: this syntax allows you to think in terms of subject, verb, object
(assert &quot;x is 3&quot;) rather than &lt;code&gt;assertEquals&lt;/code&gt;, which uses verb, object, subject (assert &quot;equals 3 x&quot;)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Combinations: any matcher statement &lt;code&gt;s&lt;/code&gt; can be negated (&lt;code&gt;not(s)&lt;/code&gt;), combined (&lt;code&gt;either(s).or(t)&lt;/code&gt;),
mapped to a collection (&lt;code&gt;each(s)&lt;/code&gt;), or used in custom combinations (&lt;code&gt;afterFiveSeconds(s)&lt;/code&gt;)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Readable failure messages.  Compare&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;assertTrue(responseString.contains(&quot;color&quot;) || responseString.contains(&quot;colour&quot;));
// ==&amp;gt; failure message: 
// java.lang.AssertionError:


assertThat(responseString, anyOf(containsString(&quot;color&quot;), containsString(&quot;colour&quot;)));
// ==&amp;gt; failure message:
// java.lang.AssertionError: 
// Expected: (a string containing &quot;color&quot; or a string containing &quot;colour&quot;)
//      got: &quot;Please choose a font&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Custom Matchers.  By implementing the &lt;code&gt;Matcher&lt;/code&gt; interface yourself, you can get all of the
above benefits for your own custom assertions.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;For a more thorough description of these points, see &lt;a href=&quot;http://joewalnes.com/2005/05/13/flexible-junit-assertions-with-assertthat/&quot;&gt;Joe Walnes's
original post&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We have decided to include this API directly in JUnit.
It's an extensible and readable syntax, and it enables
new features, like &lt;a href=&quot;#assumptions&quot;&gt;assumptions&lt;/a&gt; and &lt;a href=&quot;#theories&quot;&gt;theories&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Some notes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The old assert methods are never, ever, going away.  Developers may 
continue using the old &lt;code&gt;assertEquals&lt;/code&gt;, &lt;code&gt;assertTrue&lt;/code&gt;, and so on.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The second parameter of an &lt;code&gt;assertThat&lt;/code&gt; statement is a &lt;code&gt;Matcher&lt;/code&gt;.
We include the Matchers we want as static imports, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import static org.hamcrest.CoreMatchers.is;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import static org.hamcrest.CoreMatchers.*;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Manually importing &lt;code&gt;Matcher&lt;/code&gt; methods can be frustrating.  &lt;a href=&quot;http://www.eclipse.org/downloads/&quot;&gt;Eclipse 3.3&lt;/a&gt; includes the ability to 
define
&quot;Favorite&quot; classes to import static methods from, which makes it easier 
(Search for &quot;Favorites&quot; in the Preferences dialog).
We expect that support for static imports will improve in all Java IDEs in the future.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;To allow compatibility with a wide variety of possible matchers, 
we have decided to include the classes from hamcrest-core,
from the &lt;a href=&quot;http://code.google.com/p/hamcrest/&quot;&gt;Hamcrest&lt;/a&gt; project.  This is the first time that
third-party classes have been included in JUnit.  &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;JUnit currently ships with a few matchers, defined in 
&lt;code&gt;org.hamcrest.CoreMatchers&lt;/code&gt; and &lt;code&gt;org.junit.matchers.JUnitMatchers&lt;/code&gt;. &lt;br /&gt;
To use many, many more, consider downloading the &lt;a href=&quot;http://hamcrest.googlecode.com/files/hamcrest-all-1.1.jar&quot;&gt;full hamcrest package&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;JUnit contains special support for comparing string and array
values, giving specific information on how they differ.  This is not
yet available using the &lt;code&gt;assertThat&lt;/code&gt; syntax, but we hope to bring
the two assert methods into closer alignment in future releases.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a name=&quot;assumptions&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;Assumptions&lt;/h3&gt;

&lt;p&gt;Ideally, the developer writing a test has control of all of the forces that might cause a test to fail.
If this isn't immediately possible, making dependencies explicit can often improve a design. &lt;br /&gt;
For example, if a test fails when run in a different locale than the developer intended,
it can be fixed by explicitly passing a locale to the domain code.&lt;/p&gt;

&lt;p&gt;However, sometimes this is not desirable or possible. &lt;br /&gt;
It's good to be able to run a test against the code as it is currently written, 
implicit assumptions and all, or to write a test that exposes a known bug.
For these situations, JUnit now includes the ability to express &quot;assumptions&quot;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import static org.junit.Assume.*

@Test public void filenameIncludesUsername() {
   assumeThat(File.separatorChar, is('/'));
   assertThat(new User(&quot;optimus&quot;).configFileName(), is(&quot;configfiles/optimus.cfg&quot;));
}

@Test public void correctBehaviorWhenFilenameIsNull() {
   assumeTrue(bugFixed(&quot;13356&quot;));  // bugFixed is not included in JUnit
   assertThat(parse(null), is(new NullDocument()));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this release, a failed assumption will lead to the test being marked as passing,
regardless of what the code below the assumption may assert.
In the future, this may change, and a failed assumption may lead to the test being ignored:
however, third-party runners do not currently allow this option.&lt;/p&gt;

&lt;p&gt;We have included &lt;code&gt;assumeTrue&lt;/code&gt; for convenience, but thanks to the
inclusion of Hamcrest, we do not need to create &lt;code&gt;assumeEquals&lt;/code&gt;,
&lt;code&gt;assumeSame&lt;/code&gt;, and other analogues to the &lt;code&gt;assert*&lt;/code&gt; methods.  All of
those functionalities are subsumed in &lt;code&gt;assumeThat&lt;/code&gt;, with the appropriate
matcher.&lt;/p&gt;

&lt;p&gt;A failing assumption in a &lt;code&gt;@Before&lt;/code&gt; or &lt;code&gt;@BeforeClass&lt;/code&gt; method will have the same effect
as a failing assumption in each &lt;code&gt;@Test&lt;/code&gt; method of the class.&lt;/p&gt;

&lt;p&gt;&lt;a name=&quot;theories&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;Theories&lt;/h3&gt;

&lt;p&gt;More flexible and expressive assertions, combined with the ability to
state assumptions clearly, lead to a new kind of statement of intent, 
which we call a &quot;Theory&quot;.  A test captures the intended behavior in
one particular scenario.  A theory captures some aspect of the
intended behavior in possibly
infinite numbers of potential scenarios.  For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@RunWith(Theories.class)
public class UserTest {
  @DataPoint public static String GOOD_USERNAME = &quot;optimus&quot;;
  @DataPoint public static String USERNAME_WITH_SLASH = &quot;optimus/prime&quot;;

  @Theory public void filenameIncludesUsername(String username) {
    assumeThat(username, not(containsString(&quot;/&quot;)));
    assertThat(new User(username).configFileName(), containsString(username));
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This makes it clear that the user's filename should be included in the
config file name, only if it doesn't contain a slash.  Another test
or theory might define what happens when a username does contain a slash.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;UserTest&lt;/code&gt; will attempt to run &lt;code&gt;filenameIncludesUsername&lt;/code&gt; on 
every compatible &lt;code&gt;DataPoint&lt;/code&gt; defined in the class.  If any of the
assumptions fail, the data point is silently ignored.  If all of the
assumptions pass, but an assertion fails, the test fails.&lt;/p&gt;

&lt;p&gt;The support for Theories has been absorbed from the &lt;a href=&quot;http://popper.tigris.org&quot;&gt;Popper&lt;/a&gt;
project, and &lt;a href=&quot;http://popper.tigris.org/tutorial.html&quot;&gt;more complete documentation&lt;/a&gt; can be found
there.&lt;/p&gt;

&lt;p&gt;Defining general statements in this way can jog the developer's memory
about other potential data points and tests, also allows &lt;a href=&quot;http://www.junitfactory.org&quot;&gt;automated
tools&lt;/a&gt; to &lt;a href=&quot;http://shareandenjoy.saff.net/2007/04/popper-and-junitfactory.html&quot;&gt;search&lt;/a&gt; for new, unexpected data
points that expose bugs.&lt;/p&gt;

&lt;h3&gt;Other changes&lt;/h3&gt;

&lt;p&gt;This release contains other bug fixes and new features.  Among them:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Annotated descriptions&lt;/p&gt;

&lt;p&gt;Runner UIs, Filters, and Sorters operate on Descriptions of test
methods and test classes.  These Descriptions now include the
annotations on the original Java source element, allowing for richer
display of test results, and easier development of annotation-based
filters.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Bug fix (1715326): assertEquals now compares all Numbers using their
native implementation of &lt;code&gt;equals&lt;/code&gt;.  This assertion, which passed in
4.3, will now fail:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;assertEquals(new Integer(1), new Long(1));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Non-integer Numbers (Floats, Doubles, BigDecimals, etc),
which were compared incorrectly in 4.3, are now fixed.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;assertEquals(long, long)&lt;/code&gt; and &lt;code&gt;assertEquals(double, double)&lt;/code&gt; have
been re-introduced to the &lt;code&gt;Assert&lt;/code&gt; class, to take advantage of
Java's native widening conversions.  Therefore, this still passes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;assertEquals(1, 1L);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The default runner for JUnit 4 test classes has been refactored.
The old version was named &lt;code&gt;TestClassRunner&lt;/code&gt;, and the new is named
&lt;code&gt;JUnit4ClassRunner&lt;/code&gt;.  Likewise, &lt;code&gt;OldTestClassRunner&lt;/code&gt; is now
&lt;code&gt;JUnit3ClassRunner&lt;/code&gt;.  The new design allows variations in running
individual test classes to be expressed with fewer custom classes.
For a good example, see the source to
&lt;code&gt;org.junit.experimental.theories.Theories&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The rules for determining which runner is applied by default to a
test class have been simplified:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;If the class has a &lt;code&gt;@RunWith&lt;/code&gt; annotation, the annotated runner
class is used.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If the class can be run with the JUnit 3 test runner (it
subclasses &lt;code&gt;TestCase&lt;/code&gt;, or contains a &lt;code&gt;public static Test suite()&lt;/code&gt;
method), JUnit38ClassRunner is used.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Otherwise, JUnit4ClassRunner is used.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This default guess can always be overridden by an explicit
&lt;code&gt;@RunWith(JUnit4ClassRunner.class)&lt;/code&gt; or
&lt;code&gt;@RunWith(JUnit38ClassRunner.class)&lt;/code&gt; annotation.&lt;/p&gt;

&lt;p&gt;The old class names &lt;code&gt;TestClassRunner&lt;/code&gt; and &lt;code&gt;OldTestClassRunner&lt;/code&gt;
remain as deprecated.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Bug fix (1739095): Filters and Sorters work correctly on test
classes that contain a &lt;code&gt;suite&lt;/code&gt; method like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static junit.framework.Test suite() {
  return new JUnit4TestAdapter(MyTest.class);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Bug fix (1745048): @After methods are now correctly called 
after a test method times out.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</div>
<script src="https://www.zeljkoobrenovic.com/tools/common/lib/ace/ace.js" type="text/javascript" charset="utf-8"></script>
<script>
    var editor = ace.edit("editor");
    editor.session.setMode("ace/mode/html");
    editor.setTheme("ace/theme/xcode");
    editor.setReadOnly(true);
    editor.setOption("wrap", true);
    editor.setPrintMarginColumn(120);
</script>
</body>
