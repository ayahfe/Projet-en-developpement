<html>
<head>
    <title>src/main/java/org/junit/runner/Result.java</title>
    <style type="text/css" media="screen">
        #editor {
            position: absolute;
            top: 40px;
            right: 0;
            bottom: 0;
            left: 0;
        }
    </style>
</head>
<body style="font-family: 'DejaVu Sans', Arial, Helvetica, sans-serif">
<h3 style="margin-bottom: 0">src/main/java/org/junit/runner/Result.java (<b>151</b> lines of code) (<a href="Result.java">raw</a>):</h3>
<div id="editor">package org.junit.runner;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.ObjectStreamClass;
import java.io.ObjectStreamField;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

import org.junit.runner.notification.Failure;
import org.junit.runner.notification.RunListener;

/**
 * A &lt;code&gt;Result&lt;/code&gt; collects and summarizes information from running multiple tests.
 * All tests are counted -- additional information is collected from tests that fail.
 *
 * @since 4.0
 */
public class Result implements Serializable {
    private static final long serialVersionUID = 1L;
    private static final ObjectStreamField[] serialPersistentFields =
            ObjectStreamClass.lookup(SerializedForm.class).getFields();
    private final AtomicInteger count;
    private final AtomicInteger ignoreCount;
    private final AtomicInteger assumptionFailureCount;
    private final CopyOnWriteArrayList&lt;Failure&gt; failures;
    private final AtomicLong runTime;
    private final AtomicLong startTime;

    /** Only set during deserialization process. */
    private SerializedForm serializedForm;

    public Result() {
        count = new AtomicInteger();
        ignoreCount = new AtomicInteger();
        assumptionFailureCount = new AtomicInteger();
        failures = new CopyOnWriteArrayList&lt;Failure&gt;();
        runTime = new AtomicLong();
        startTime = new AtomicLong();
    }

    private Result(SerializedForm serializedForm) {
        count = serializedForm.fCount;
        ignoreCount = serializedForm.fIgnoreCount;
        assumptionFailureCount = serializedForm.assumptionFailureCount;
        failures = new CopyOnWriteArrayList&lt;Failure&gt;(serializedForm.fFailures);
        runTime = new AtomicLong(serializedForm.fRunTime);
        startTime = new AtomicLong(serializedForm.fStartTime);
    }

    /**
     * Returns the number of tests run
     */
    public int getRunCount() {
        return count.get();
    }

    /**
     * Returns the number of tests that failed during the run
     */
    public int getFailureCount() {
        return failures.size();
    }

    /**
     * Returns the number of milliseconds it took to run the entire suite to run
     */
    public long getRunTime() {
        return runTime.get();
    }

    /**
     * Returns the {@link Failure}s describing tests that failed and the problems they encountered
     */
    public List&lt;Failure&gt; getFailures() {
        return failures;
    }

    /**
     * @return the number of tests ignored during the run
     */
    public int getIgnoreCount() {
        return ignoreCount.get();
    }

    /**
     * Returns the number of tests skipped because of an assumption failure
     *
     * @throws UnsupportedOperationException if the result was serialized in a version before JUnit 4.13
     * @since 4.13
     */
    public int getAssumptionFailureCount() {
        if (assumptionFailureCount == null) {
            throw new UnsupportedOperationException(
                    &quot;Result was serialized from a version of JUnit that doesn't support this method&quot;);
        }
        return assumptionFailureCount.get();
    }

    /**
     * @return &lt;code&gt;true&lt;/code&gt; if all tests succeeded
     */
    public boolean wasSuccessful() {
        return getFailureCount() == 0;
    }

    private void writeObject(ObjectOutputStream s) throws IOException {
        SerializedForm serializedForm = new SerializedForm(this);
        serializedForm.serialize(s);
    }

    private void readObject(ObjectInputStream s)
            throws ClassNotFoundException, IOException {
        serializedForm = SerializedForm.deserialize(s);
    }

    private Object readResolve()  {
        return new Result(serializedForm);
    }

    @RunListener.ThreadSafe
    private class Listener extends RunListener {
        @Override
        public void testRunStarted(Description description) throws Exception {
            startTime.set(System.currentTimeMillis());
        }

        @Override
        public void testRunFinished(Result result) throws Exception {
            long endTime = System.currentTimeMillis();
            runTime.addAndGet(endTime - startTime.get());
        }

        @Override
        public void testFinished(Description description) throws Exception {
            count.getAndIncrement();
        }

        @Override
        public void testFailure(Failure failure) throws Exception {
            failures.add(failure);
        }

        @Override
        public void testIgnored(Description description) throws Exception {
            ignoreCount.getAndIncrement();
        }

        @Override
        public void testAssumptionFailure(Failure failure) {
            assumptionFailureCount.getAndIncrement();
        }
    }

    /**
     * Internal use only.
     */
    public RunListener createListener() {
        return new Listener();
    }

    /**
     * Represents the serialized output of {@code Result}. The fields on this
     * class match the files that {@code Result} had in JUnit 4.11.
     */
    private static class SerializedForm implements Serializable {
        private static final long serialVersionUID = 1L;
        private final AtomicInteger fCount;
        private final AtomicInteger fIgnoreCount;
        private final AtomicInteger assumptionFailureCount;
        private final List&lt;Failure&gt; fFailures;
        private final long fRunTime;
        private final long fStartTime;

        public SerializedForm(Result result) {
            fCount = result.count;
            fIgnoreCount = result.ignoreCount;
            assumptionFailureCount = result.assumptionFailureCount;
            fFailures = Collections.synchronizedList(new ArrayList&lt;Failure&gt;(result.failures));
            fRunTime = result.runTime.longValue();
            fStartTime = result.startTime.longValue();
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        private SerializedForm(ObjectInputStream.GetField fields) throws IOException, ClassNotFoundException {
            fCount = (AtomicInteger) fields.get(&quot;fCount&quot;, null);
            fIgnoreCount = (AtomicInteger) fields.get(&quot;fIgnoreCount&quot;, null);
            assumptionFailureCount = (AtomicInteger) fields.get(&quot;assumptionFailureCount&quot;, null);
            fFailures = (List&lt;Failure&gt;) fields.get(&quot;fFailures&quot;, null);
            fRunTime = fields.get(&quot;fRunTime&quot;, 0L);
            fStartTime = fields.get(&quot;fStartTime&quot;, 0L);
        }

        public void serialize(ObjectOutputStream s) throws IOException {
            ObjectOutputStream.PutField fields = s.putFields();
            fields.put(&quot;fCount&quot;, fCount);
            fields.put(&quot;fIgnoreCount&quot;, fIgnoreCount);
            fields.put(&quot;fFailures&quot;, fFailures);
            fields.put(&quot;fRunTime&quot;, fRunTime);
            fields.put(&quot;fStartTime&quot;, fStartTime);
            fields.put(&quot;assumptionFailureCount&quot;, assumptionFailureCount);
            s.writeFields();
        }

        public static SerializedForm deserialize(ObjectInputStream s)
                throws ClassNotFoundException, IOException {
            ObjectInputStream.GetField fields = s.readFields();
            return new SerializedForm(fields);
        }
    }
}
</div>
<script src="https://www.zeljkoobrenovic.com/tools/common/lib/ace/ace.js" type="text/javascript" charset="utf-8"></script>
<script>
    var editor = ace.edit("editor");
    editor.session.setMode("ace/mode/java");
    editor.setTheme("ace/theme/xcode");
    editor.setReadOnly(true);
    editor.setOption("wrap", true);
    editor.setPrintMarginColumn(120);
</script>
</body>
