<html>
<head>
    <title>src/main/java/org/junit/experimental/theories/Theories.java</title>
    <style type="text/css" media="screen">
        #editor {
            position: absolute;
            top: 40px;
            right: 0;
            bottom: 0;
            left: 0;
        }
    </style>
</head>
<body style="font-family: 'DejaVu Sans', Arial, Helvetica, sans-serif">
<h3 style="margin-bottom: 0">src/main/java/org/junit/experimental/theories/Theories.java (<b>218</b> lines of code) (<a href="Theories.java">raw</a>):</h3>
<div id="editor">package org.junit.experimental.theories;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.List;

import org.junit.Assert;
import org.junit.Assume;
import org.junit.experimental.theories.internal.Assignments;
import org.junit.experimental.theories.internal.ParameterizedAssertionError;
import org.junit.internal.AssumptionViolatedException;
import org.junit.runners.BlockJUnit4ClassRunner;
import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.InitializationError;
import org.junit.runners.model.Statement;
import org.junit.runners.model.TestClass;

/**
 * The Theories runner allows to test a certain functionality against a subset of an infinite set of data points.
 * &lt;p&gt;
 * A Theory is a piece of functionality (a method) that is executed against several data inputs called data points.
 * To make a test method a theory you mark it with &lt;b&gt;&amp;#064;Theory&lt;/b&gt;. To create a data point you create a public
 * field in your test class and mark it with &lt;b&gt;&amp;#064;DataPoint&lt;/b&gt;. The Theories runner then executes your test
 * method as many times as the number of data points declared, providing a different data point as
 * the input argument on each invocation.
 * &lt;/p&gt;
 * &lt;p&gt;
 * A Theory differs from standard test method in that it captures some aspect of the intended behavior in possibly
 * infinite numbers of scenarios which corresponds to the number of data points declared. Using assumptions and
 * assertions properly together with covering multiple scenarios with different data points can make your tests more
 * flexible and bring them closer to scientific theories (hence the name).
 * &lt;/p&gt;
 * &lt;p&gt;
 * For example:
 * &lt;pre&gt;
 *
 * &amp;#064;RunWith(&lt;b&gt;Theories.class&lt;/b&gt;)
 * public class UserTest {
 *      &lt;b&gt;&amp;#064;DataPoint&lt;/b&gt;
 *      public static String GOOD_USERNAME = &quot;optimus&quot;;
 *      &lt;b&gt;&amp;#064;DataPoint&lt;/b&gt;
 *      public static String USERNAME_WITH_SLASH = &quot;optimus/prime&quot;;
 *
 *      &lt;b&gt;&amp;#064;Theory&lt;/b&gt;
 *      public void filenameIncludesUsername(String username) {
 *          assumeThat(username, not(containsString(&quot;/&quot;)));
 *          assertThat(new User(username).configFileName(), containsString(username));
 *      }
 * }
 * &lt;/pre&gt;
 * This makes it clear that the username should be included in the config file name,
 * only if it doesn't contain a slash. Another test or theory might define what happens when a username does contain
 * a slash. &lt;code&gt;UserTest&lt;/code&gt; will attempt to run &lt;code&gt;filenameIncludesUsername&lt;/code&gt; on every compatible data
 * point defined in the class. If any of the assumptions fail, the data point is silently ignored. If all of the
 * assumptions pass, but an assertion fails, the test fails. If no parameters can be found that satisfy all assumptions, the test fails.
 * &lt;p&gt;
 * Defining general statements as theories allows data point reuse across a bunch of functionality tests and also
 * allows automated tools to search for new, unexpected data points that expose bugs.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The support for Theories has been absorbed from the Popper project, and more complete documentation can be found
 * from that projects archived documentation.
 * &lt;/p&gt;
 *
 * @see &lt;a href=&quot;http://web.archive.org/web/20071012143326/popper.tigris.org/tutorial.html&quot;&gt;Archived Popper project documentation&lt;/a&gt;
 * @see &lt;a href=&quot;http://web.archive.org/web/20110608210825/http://shareandenjoy.saff.net/tdd-specifications.pdf&quot;&gt;Paper on Theories&lt;/a&gt;
 */
public class Theories extends BlockJUnit4ClassRunner {
    public Theories(Class&lt;?&gt; klass) throws InitializationError {
        super(klass);
    }

    /** @since 4.13 */
    protected Theories(TestClass testClass) throws InitializationError {
        super(testClass);
    }

    @Override
    protected void collectInitializationErrors(List&lt;Throwable&gt; errors) {
        super.collectInitializationErrors(errors);
        validateDataPointFields(errors);
        validateDataPointMethods(errors);
    }

    private void validateDataPointFields(List&lt;Throwable&gt; errors) {
        Field[] fields = getTestClass().getJavaClass().getDeclaredFields();

        for (Field field : fields) {
            if (field.getAnnotation(DataPoint.class) == null &amp;&amp; field.getAnnotation(DataPoints.class) == null) {
                continue;
            }
            if (!Modifier.isStatic(field.getModifiers())) {
                errors.add(new Error(&quot;DataPoint field &quot; + field.getName() + &quot; must be static&quot;));
            }
            if (!Modifier.isPublic(field.getModifiers())) {
                errors.add(new Error(&quot;DataPoint field &quot; + field.getName() + &quot; must be public&quot;));
            }
        }
    }

    private void validateDataPointMethods(List&lt;Throwable&gt; errors) {
        Method[] methods = getTestClass().getJavaClass().getDeclaredMethods();
        
        for (Method method : methods) {
            if (method.getAnnotation(DataPoint.class) == null &amp;&amp; method.getAnnotation(DataPoints.class) == null) {
                continue;
            }
            if (!Modifier.isStatic(method.getModifiers())) {
                errors.add(new Error(&quot;DataPoint method &quot; + method.getName() + &quot; must be static&quot;));
            }
            if (!Modifier.isPublic(method.getModifiers())) {
                errors.add(new Error(&quot;DataPoint method &quot; + method.getName() + &quot; must be public&quot;));
            }
        }
    }

    @Override
    protected void validateConstructor(List&lt;Throwable&gt; errors) {
        validateOnlyOneConstructor(errors);
    }

    @Override
    protected void validateTestMethods(List&lt;Throwable&gt; errors) {
        for (FrameworkMethod each : computeTestMethods()) {
            if (each.getAnnotation(Theory.class) != null) {
                each.validatePublicVoid(false, errors);
                each.validateNoTypeParametersOnArgs(errors);
            } else {
                each.validatePublicVoidNoArg(false, errors);
            }
            
            for (ParameterSignature signature : ParameterSignature.signatures(each.getMethod())) {
                ParametersSuppliedBy annotation = signature.findDeepAnnotation(ParametersSuppliedBy.class);
                if (annotation != null) {
                    validateParameterSupplier(annotation.value(), errors);
                }
            }
        }
    }

    private void validateParameterSupplier(Class&lt;? extends ParameterSupplier&gt; supplierClass, List&lt;Throwable&gt; errors) {
        Constructor&lt;?&gt;[] constructors = supplierClass.getConstructors();
        
        if (constructors.length != 1) {
            errors.add(new Error(&quot;ParameterSupplier &quot; + supplierClass.getName() + 
                                 &quot; must have only one constructor (either empty or taking only a TestClass)&quot;));
        } else {
            Class&lt;?&gt;[] paramTypes = constructors[0].getParameterTypes();
            if (!(paramTypes.length == 0) &amp;&amp; !paramTypes[0].equals(TestClass.class)) {
                errors.add(new Error(&quot;ParameterSupplier &quot; + supplierClass.getName() + 
                                     &quot; constructor must take either nothing or a single TestClass instance&quot;));
            }
        }
    }

    @Override
    protected List&lt;FrameworkMethod&gt; computeTestMethods() {
        List&lt;FrameworkMethod&gt; testMethods = new ArrayList&lt;FrameworkMethod&gt;(super.computeTestMethods());
        List&lt;FrameworkMethod&gt; theoryMethods = getTestClass().getAnnotatedMethods(Theory.class);
        testMethods.removeAll(theoryMethods);
        testMethods.addAll(theoryMethods);
        return testMethods;
    }

    @Override
    public Statement methodBlock(final FrameworkMethod method) {
        return new TheoryAnchor(method, getTestClass());
    }

    public static class TheoryAnchor extends Statement {
        private int successes = 0;

        private final FrameworkMethod testMethod;
        private final TestClass testClass;

        private List&lt;AssumptionViolatedException&gt; fInvalidParameters = new ArrayList&lt;AssumptionViolatedException&gt;();

        public TheoryAnchor(FrameworkMethod testMethod, TestClass testClass) {
            this.testMethod = testMethod;
            this.testClass = testClass;
        }

        private TestClass getTestClass() {
            return testClass;
        }

        @Override
        public void evaluate() throws Throwable {
            runWithAssignment(Assignments.allUnassigned(
                    testMethod.getMethod(), getTestClass()));
            
            //if this test method is not annotated with Theory, then no successes is a valid case
            boolean hasTheoryAnnotation = testMethod.getAnnotation(Theory.class) != null;
            if (successes == 0 &amp;&amp; hasTheoryAnnotation) {
                Assert
                        .fail(&quot;Never found parameters that satisfied method assumptions.  Violated assumptions: &quot;
                                + fInvalidParameters);
            }
        }

        protected void runWithAssignment(Assignments parameterAssignment)
                throws Throwable {
            if (!parameterAssignment.isComplete()) {
                runWithIncompleteAssignment(parameterAssignment);
            } else {
                runWithCompleteAssignment(parameterAssignment);
            }
        }

        protected void runWithIncompleteAssignment(Assignments incomplete)
                throws Throwable {
            for (PotentialAssignment source : incomplete
                    .potentialsForNextUnassigned()) {
                runWithAssignment(incomplete.assignNext(source));
            }
        }

        protected void runWithCompleteAssignment(final Assignments complete)
                throws Throwable {
            new BlockJUnit4ClassRunner(getTestClass()) {
                @Override
                protected void collectInitializationErrors(
                        List&lt;Throwable&gt; errors) {
                    // do nothing
                }

                @Override
                public Statement methodBlock(FrameworkMethod method) {
                    final Statement statement = super.methodBlock(method);
                    return new Statement() {
                        @Override
                        public void evaluate() throws Throwable {
                            try {
                                statement.evaluate();
                                handleDataPointSuccess();
                            } catch (AssumptionViolatedException e) {
                                handleAssumptionViolation(e);
                            } catch (Throwable e) {
                                reportParameterizedError(e, complete
                                        .getArgumentStrings(nullsOk()));
                            }
                        }

                    };
                }

                @Override
                protected Statement methodInvoker(FrameworkMethod method, Object test) {
                    return methodCompletesWithParameters(method, complete, test);
                }

                @Override
                public Object createTest() throws Exception {
                    Object[] params = complete.getConstructorArguments();
                    
                    if (!nullsOk()) {
                        Assume.assumeNotNull(params);
                    }
                    
                    return getTestClass().getOnlyConstructor().newInstance(params);
                }
            }.methodBlock(testMethod).evaluate();
        }

        private Statement methodCompletesWithParameters(
                final FrameworkMethod method, final Assignments complete, final Object freshInstance) {
            return new Statement() {
                @Override
                public void evaluate() throws Throwable {
                    final Object[] values = complete.getMethodArguments();
                    
                    if (!nullsOk()) {
                        Assume.assumeNotNull(values);
                    }
                    
                    method.invokeExplosively(freshInstance, values);
                }
            };
        }

        protected void handleAssumptionViolation(AssumptionViolatedException e) {
            fInvalidParameters.add(e);
        }

        protected void reportParameterizedError(Throwable e, Object... params)
                throws Throwable {
            if (params.length == 0) {
                throw e;
            }
            throw new ParameterizedAssertionError(e, testMethod.getName(),
                    params);
        }

        private boolean nullsOk() {
            Theory annotation = testMethod.getMethod().getAnnotation(
                    Theory.class);
            if (annotation == null) {
                return false;
            }
            return annotation.nullsAccepted();
        }

        protected void handleDataPointSuccess() {
            successes++;
        }
    }
}
</div>
<script src="https://www.zeljkoobrenovic.com/tools/common/lib/ace/ace.js" type="text/javascript" charset="utf-8"></script>
<script>
    var editor = ace.edit("editor");
    editor.session.setMode("ace/mode/java");
    editor.setTheme("ace/theme/xcode");
    editor.setReadOnly(true);
    editor.setOption("wrap", true);
    editor.setPrintMarginColumn(120);
</script>
</body>
